# -*- coding: utf-8 -*-
"""CNN1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_oE-qL0nLJYS-m5z1P4apBU3nfgnjAN_

Linkar o Google Drive no Colab
"""

from google.colab import drive
drive.mount('/content/drive')

"""Criar a Rede Neural"""

import tensorflow as tf  # Biblioteca para criar a rede neural
from tensorflow import keras
from keras import layers
import matplotlib.pyplot as plt  # Para visualizar imagens
import numpy as np  # Para manipulação de arrays
import matplotlib.pyplot as plt  # Para visualizar imagens
import os  # Para trabalhar com diretórios
import tensorflow as tf  # Biblioteca para criar a rede neural
from tensorflow import keras


# Definir o caminho do dataset
dataset_path = "/content/drive/MyDrive/6 PERIODO/Eng. do Produto/Dataset_Separado"

# Criar os datasets de treino, teste e validação
train_dataset = keras.preprocessing.image_dataset_from_directory(
    os.path.join(dataset_path, "train"),
    image_size=(227, 227),
    batch_size=32,
    shuffle=True,
    label_mode='binary')

test_dataset = keras.preprocessing.image_dataset_from_directory(
    os.path.join(dataset_path, "test"),
    image_size=(227, 227),
    batch_size=32,
    shuffle=True,
    label_mode='binary')

validation_dataset = keras.preprocessing.image_dataset_from_directory(
    os.path.join(dataset_path, "validation"),
    image_size=(227, 227),
    batch_size=32,
    shuffle=True,
    label_mode='binary')


# Criando a CNN
model = keras.Sequential([

    # Camada 1: Convolução + Pooling + Dropout
    layers.Conv2D(32, (3,3), activation='relu', input_shape=(227, 227, 3)),
    layers.MaxPooling2D(2,2), layers.Dropout(0.2),

    # Camada 2: Convolução + Pooling + Dropout
    layers.Conv2D(64, (3,3), activation='relu'),
    layers.MaxPooling2D(2,2), layers.Dropout(0.2),

    # Camada 3: Convolução + Pooling
    layers.Conv2D(128, (3,3), activation='relu'),
    layers.MaxPooling2D(2,2), #Não precisa colocar dropout antes da flatten

    # Camada 4: Flatten (Achatar as Matrizes)
    layers.Flatten(),

    # Camada 5: Fully Connected (Densa)
    layers.Dense(512, activation='relu'),

    # Camada 6: Saída (2 classes: com fissura ou sem fissura)
    layers.Dense(1, activation='sigmoid')])

model.compile(
    loss="binary_crossentropy",
    optimizer="adam",
    metrics=["accuracy"])

"""Imprimir o nome das classes / Imprimir as classes com imagens"""

print(train_dataset.class_names)
print(test_dataset.class_names)
print(validation_dataset.class_names)

plt.figure(figsize=(10, 10))
for images, labels in train_dataset.take(1):
  for i in range(9):
    ax = plt.subplot(3, 3, i + 1)
    plt.imshow(images[i].numpy().astype("uint8"))
    plt.title(train_dataset.class_names[labels[i]])
    plt.axis("off")
plt.show()

"""Treinar o modelo"""

history = model.fit(
    train_dataset,
    validation_data=validation_dataset,
    epochs=10
)

"""Avaliar o modelo"""

loss, accuracy = model.evaluate(test_dataset)
print(f"Acurácia: {accuracy * 100:.2f}%")

"""Segunda Avaliação para teste de Acurácia"""

loss, accuracy = model.evaluate(test_dataset)
print(f"Acurácia: {accuracy * 100:.2f}%")

"""Salvar o modelo"""

import os
os.listdir()

"""Baixando o modelo usando o Keras"""

model.save('/content/drive/MyDrive/fissuras227x227.keras')



"""

